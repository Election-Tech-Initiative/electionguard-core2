<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.Json" #>
<#@ import namespace="ElectionGuard.InteropGenerator.Helpers" #>
<#
var className = EgClass.ClassName;
#>
// DO NOT MODIFY THIS FILE
// This file is generated via ElectionGuard.InteropGenerator at /src/interop-generator

using System;
using System.Runtime.InteropServices;
using System.Runtime.ConstrainedExecution;

namespace ElectionGuard
{
    public partial class <#= className #>
    {
        internal External.<#= className #>Handle Handle;

        #region Properties
<# foreach (var egProperty in EgClass.Properties) { 
        var isInternalType = egProperty.NativeHandleType != null;
        #>
        /// <Summary>
        /// <#= egProperty.Description #>
        /// </Summary>
        public <#= egProperty.TypeCs #> <#= egProperty.Name #>
        {
            get
            {
<# if (isInternalType) { #>
                var status = External.Get<#= egProperty.Name #>(
                    Handle, out <#= egProperty.NativeHandleType #> value);
                status.ThrowIfError();
                return new <#= egProperty.TypeCs #>(value);
<# } else if (egProperty.TypeCs == "string") { #>
                var status = External.Get<#= egProperty.Name #>(Handle, out IntPtr value);
                status.ThrowIfError();
                var data = Marshal.PtrToStringAnsi(value);
                NativeInterface.Memory.FreeIntPtr(value);
                return data;
<# } else { #>
                return External.Get<#= egProperty.Name #>(Handle);
<# } #>
            }
        }

<#} // foreach EgProperty#>
        #endregion

        #region Methods
<# foreach (var method in EgClass.Methods) { #>
        /// <summary>
        /// <#= method.Description #>
        /// </summary>
        public <#= method.ReturnTypeCs #> <#= method.Name #>(
            <#= string.Join(", ", method.Params.Select(p => p.AsCsParam())) #>
        ) {
            return External.<#= method.Name #>(
                Handle<# 
foreach (var p in method.Params) {
    this.Write($", {p.Name}");
}
                #>);
        }
<# } // foreach method #>

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
        protected override void DisposeUnmanaged()
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
        {
            base.DisposeUnmanaged();

            if (Handle == null || Handle.IsInvalid) return;
            Handle.Dispose();
            Handle = null;
        }
        #endregion

        #region Extern
        internal static unsafe class External {
            internal struct <#= className #>Type { };

            internal class <#= className #>Handle : ElectionGuardSafeHandle<<#= className #>Type>
            {
                [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]
                protected override bool Free()
                {
<#
if (EgClass.NeverFree) {
#>
                    // releasing the C++ memory is currently handled by a parent object e.g. ballot, see https://github.com/microsoft/electionguard-core2/issues/29
                    return true;
<#
} else {
#>
                    if (IsFreed) return true;

                    var status = External.Free(TypedPtr);
                    if (status != Status.ELECTIONGUARD_STATUS_SUCCESS)
                    {
                        throw new ElectionGuardException($"<#= className #> Error Free: {status}", status);
                    }
                    return true;
<#
}
#>
                }
            }

            [DllImport(NativeInterface.DllName, EntryPoint = "eg_<#= className.ToSnakeCase() #>_free",
                CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
            internal static extern Status Free(<#= className #>Type* handle);

<# foreach (var egProperty in EgClass.Properties) {
        var entryPoint = egProperty.GetEntryPoint(className);
        var isInternalType = egProperty.NativeHandleType != null;
        var isComplexType = egProperty.TypeCs == "string" || isInternalType;
#>
            [DllImport(
                NativeInterface.DllName,
                EntryPoint = "<#= entryPoint #>",
                CallingConvention = CallingConvention.Cdecl, 
                SetLastError = true
            )]
            internal static extern <#= isComplexType ? "Status" : egProperty.TypeCs #> Get<#= egProperty.Name #>(
                <#= className #>Handle handle
<# if (isInternalType) { #>
                , out <#= egProperty.NativeHandleType #> objectId
<# } else if (egProperty.TypeCs == "string") { #>
                , out IntPtr objectId
<# } // end is internal type #>
            );

<# } // end foreach property #>
<# foreach (var method in EgClass.Methods) {
    var entryPoint = method.GetEntryPoint(className);
#>
            [DllImport(NativeInterface.DllName, EntryPoint = "<#= entryPoint #>",
                CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
            internal static extern <#= method.ReturnTypeCs #> <#= method.Name #>(
                <#= className #>Handle handle<#
foreach (var p in method.Params) { #>,
                <#= p.AsCppInteropParam() #><# 
} // end foreach param #>

                );
<# } #>
        }
        #endregion
    }
}
