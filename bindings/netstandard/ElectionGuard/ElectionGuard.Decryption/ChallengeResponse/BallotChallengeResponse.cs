using System.Linq;
using ElectionGuard.Ballot;
using ElectionGuard.Decryption.Challenge;
using ElectionGuard.Decryption.Shares;
using ElectionGuard.ElectionSetup;
using ElectionGuard.ElectionSetup.Extensions;
using Newtonsoft.Json;

namespace ElectionGuard.Decryption.ChallengeResponse;

/// <summary>
/// The response to a challenge that is generated by a guardian to prove that the decryption share was computed correctly.
/// </summary>
public record BallotChallengeResponse
    : DisposableRecordBase, IEquatable<BallotChallengeResponse>
{
    /// <summary>
    /// The object id of the tally
    /// </summary>
    public string TallyId { get; init; }

    /// <summary>
    /// The object id of the contest
    /// </summary>
    public string ObjectId { get; init; }

    /// <summary>
    /// The object id of the contest
    /// </summary>
    public string GuardianId { get; init; }

    /// <summary>
    /// sequence order of the guardian
    /// </summary>
    public ulong SequenceOrder { get; init; }

    /// <summary>
    /// the lagrange coefficient for the guardian
    /// </summary>
    public ElementModQ Coefficient { get; init; }

    public Dictionary<string, ContestChallengeResponse> Contests { get; init; } = default!;

    [JsonConstructor]
    public BallotChallengeResponse(
        string tallyId,
        string objectId,
        string guardianId,
        ulong sequenceOrder,
        ElementModQ coefficient,
        Dictionary<string, ContestChallengeResponse> contests)
    {
        TallyId = tallyId;
        ObjectId = objectId;
        GuardianId = guardianId;
        SequenceOrder = sequenceOrder;
        Coefficient = new(coefficient);
        Contests = contests
            .ToDictionary(
                kvp => kvp.Key,
                kvp => new ContestChallengeResponse(kvp.Value));
    }

    public BallotChallengeResponse(
        BallotChallenge challenge)
    {
        TallyId = challenge.TallyId;
        ObjectId = challenge.ObjectId;
        GuardianId = challenge.GuardianId;
        SequenceOrder = challenge.SequenceOrder;
        Coefficient = new(challenge.Coefficient);
        Contests = challenge
            .ToContestChallengeResponseDictionary();
    }

    public BallotChallengeResponse(BallotChallengeResponse other) : base(other)
    {
        TallyId = other.TallyId;
        ObjectId = other.ObjectId;
        GuardianId = other.GuardianId;
        SequenceOrder = other.SequenceOrder;
        Coefficient = new(other.Coefficient);
        Contests = other.Contests
            .ToDictionary(x => x.Key, x => new ContestChallengeResponse(x.Value));
    }

    /// <summary>
    /// Adds a selection challenge response to the contest response
    /// </summary>
    public void Add(
        IElectionContest contest,
        SelectionChallengeResponse selection)
    {
        Contests[contest.ObjectId].Add(selection);
    }

    public bool IsValid(
        CiphertextBallot ballot,
        ElementModP commitmentOffset,
        BallotShare share,
        BallotChallenge challenge)
    {
        foreach (var (contestId, contest) in Contests)
        {
            if (!contest.IsValid(
                ballot.Contests.First(x => x.ObjectId == contestId),
                commitmentOffset,
                share.Contests[contestId],
                challenge.Contests[contestId]
            ))
            {
                return false;
            }
        }

        return true;
    }

    protected override void DisposeManaged()
    {
        base.DisposeManaged();
        Contests.Dispose();
    }

    protected override void DisposeUnmanaged()
    {
        base.DisposeUnmanaged();
        Coefficient?.Dispose();
    }
}

public static partial class BallotChallengeExtensions
{
    /// <summary>
    /// Converts an internal manifest to a dictionary of CiphertextTallyContest
    /// </summary>
    public static Dictionary<string, ContestChallengeResponse> ToContestChallengeResponseDictionary(
        this BallotChallenge accumulated)
    {
        var contests = new Dictionary<string, ContestChallengeResponse>();
        foreach (var (contestId, contest) in accumulated.Contests)
        {
            contests.Add(
                contest.ObjectId,
                new ContestChallengeResponse(contest));
        }
        return contests;
    }
}


